[{"categories":["算法"],"content":"Java实现生产者消费者模型 ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:0:0","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"前言 什么是生产者消费者模型？ 简单来讲就是有两种线程，分别称为生产者线程和消费者线程。生产者线程生产出\"产品\"放置到公共的一个队列中，然后消费者线程从队列中去取该\"商品\"。这就是该模型的简单描述。 异步和解耦 该模型实现了生产者和消费的异步和解耦。生产者只需要生产出\"产品\"放到不满的队列中就可以，并不需要关心是谁来消费，可能是小红可能是大黄，也不需要等待消费者消费完了之后再接着生产。消费者也不需要关心\"产品\"是谁生产的，只要队列里面有\"产品\"，我就可以拿去用，不用等生产者一个个生产。 那该怎么实现？ 总结一下该模型的几点需要实现的点： 生产者和消费者线程需要通信 需要一个线程安全的队列来存放\"产品\" 那么我们可以根据所学过的线程间通信的方法来选择 线程通信方式 volatile关键字保证共享变量在线程间的可见性 基于synchronized锁的wait/notify的等待通知机制 基于AQS并发包的ReentrantLock等并发工具 管道流 保证队列线程安全 使用线程不安全的队列，但是对其访问进行加锁 使用线程安全的队列 那么可以总结出以下几种方法 基于synchronized锁的wait/notify的等待通知机制 + 线程不安全的队列 基于AQS并发包的Lock和Condition的条件等待机制 + 线程不安全的队列 基于BlockingQueue阻塞队列的入列和出列机制(BlockingQueue本身是线程安全的) ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:1:0","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"synchronized 先讲基于synchronized的等待通知机制。 synchronized锁 当我们对queue加上synchronized锁之后，我们调用方法queue.wait就会在该锁的一个叫做waitSet的等待队列上进行等待，直到有别的线程调用notify/notifyAll(notify则进行随机唤醒)。那么我们就可以得到如下的流程图。 使用synchronized锁的生产者消费者模型image-20220109211436965 \"\r使用synchronized锁的生产者消费者模型\r 每个线程大致的步骤是： 线程运行到获取的锁的位置 尝试获取锁，若获取失败，则在同步队列中继续获取，回到步骤1。若成功则拿到锁则到步骤3。 获取锁之后，尝试将产品加入到queue/从queue拿出产品。若不符合条件(生产者发现队列满了，消费者发现队列为空)，则加入到该锁的等待队列waitSet中，并且让出该锁，到步骤4。若符合条件则正常操作，并且唤醒所有等待在该锁的waitSet上的线程，也就是notifyAll，并且让出该锁、回到步骤1。 在waitSet等待唤醒，若被唤醒则从到锁的同步队列中继续尝试获取锁，若获取成功则到直接到操作队列步骤。失败则继续尝试获取锁。 ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:2:0","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"代码实例 废话不多说，直接上代码。 定义 生产者：新手程序员 消费者：老手程序员 产品：Bug 对立：系统 新手程序员作为Bug的生产者来生产Bug到系统中，由老手程序员作为消费者来从系统中找到Bug并修复 Bug类 /** * @author TheR1sing3un * @date 2022/1/9 17:18 * @description Bug类 */ public class Bug { private Integer bugId; public Bug(Integer bugId){ this.bugId = bugId; } public Integer getBugId() { return bugId; } } Producer类 import java.util.Queue; import java.util.Random; /** * @author TheR1sing3un * @date 2022/1/9 17:03 * @description */ public class Producer extends Thread { private String name; private int maxSize; private Queue\u003cBug\u003e queue; /** * 构造方法 * @param name * @param queue * @param maxSize */ public Producer(String name,Queue\u003cBug\u003e queue,int maxSize){ this.name = name; this.maxSize = maxSize; this.queue = queue; } /** * 重写run方法,来不断生产bug到队列中 */ @Override public void run() { Random random = new Random(); while(true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //生产者不断生产bug Bug bug = this.produceBug(random.nextInt()); //模拟耗时操作 //加锁,避免并发问题 synchronized (this.queue){ while(queue.size() == maxSize){ //当前的队列已满,无法将bug放进去,那么就等待,直到被唤醒(消费者会来唤醒的) try { System.out.println(\"[\" + name + \"]: 当前系统的Bug达到上限,歇会儿,不满的时候跟俺说一声~\"); queue.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //现在可以把bug放进去了 queue.add(bug); System.out.println(\"[\" + name + \"]: 俺往系统里面放了一个Bug\" + bug.getBugId() + \",嘿嘿~嘿嘿嘿~\"); //唤醒在睡眠的消费者(当时那些消费者消费的时候发现队列为空,就sleep去了,现在我刚放进去一个bug,队列肯定不为空,所以唤醒他们) queue.notifyAll(); } } } /** * * 生产者生产一个带编号的Bug(可真是和我一模一样呢) * @param i * @return */ public Bug produceBug(int i){ Bug bug = new Bug(i); return bug; } } Cunsumer类 import java.util.Queue; /** * @author TheR1sing3un * @date 2022/1/9 17:32 * @description 消费者 */ public class Consumer extends Thread{ private String name; private Queue\u003cBug\u003e queue; public Consumer(String name, Queue\u003cBug\u003e queue) { this.name = name; this.queue = queue; } /** * 重写run方法,消费者从队列中拿Bug,然后去修复(消费者就是修复Bug的可怜程序员) */ @Override public void run() { while (true){ //操作队列就要上锁! synchronized (queue){ while (queue.isEmpty()){ //当队列中没有Bug时,就等待 try { System.out.println(\"[\" + name + \"]: 这系统做的可以,咋没Bug,整挺好,我摸鱼去了,有Bug叫我\"); queue.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //有bug时取出 Bug bug = queue.poll(); //模拟耗时操作 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } fixBug(bug); //唤醒生产者线程 queue.notifyAll(); } } } /** * 消费者修复Bug * @param bug */ public void fixBug(Bug bug){ System.out.println(\"[\" + name + \"]: 修复了Bug\" + bug.getBugId()); } } 测试 import java.util.LinkedList; import java.util.Queue; /** * @author TheR1sing3un * @date 2022/1/9 17:41 * @description */ public class Test { public static void main(String[] args) { Queue\u003cBug\u003e queue = new LinkedList\u003c\u003e(); int maxSize = 3; for (int i = 0; i \u003c 5; i++) { new Producer(\"新手程序员\"+i+\"号\",queue,maxSize).start(); } for (int i = 0; i \u003c 2; i++) { new Consumer(\"老手程序员\"+i+\"号\",queue).start(); } } } 测试截图如下： ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:2:1","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"AQS并发包 方案二采取AQS并发包中的Lock和Condition的条件等待来实现。 加锁步骤和方案一差不多，只需要将queue.wait改成相应的条件等待，以及唤醒改成条件唤醒即可 生产者 生产者尝试往队列里面放的时候若队列是满的，则在条件变量noFull上等队列不为满的时候。 若生产者成功将元素放进队列，那么此时队列一定不为空，所以唤醒在noEmpty条件变量上等待的消费者。 消费者 消费者尝试从队列里面取的时候若队列为空，则在条件变量noEmpty上等到队列不为空的时候。 若消费者成功从队列取到元素，那么此时队列一定不是满的，所以唤醒在noFull条件变量上等待的生产者。 ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:3:0","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"代码实例 Bug类 package ProAndCon; /** * @author TheR1sing3un * @date 2022/1/9 17:18 * @description Bug类 */ public class Bug { private Integer bugId; public Bug(Integer bugId){ this.bugId = bugId; } public Integer getBugId() { return bugId; } } Producer类 package ProAndCon; import javax.security.auth.login.Configuration; import java.util.Queue; import java.util.Random; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; /** * @author TheR1sing3un * @date 2022/1/9 22:03 * @description 生产者类 */ public class Producer extends Thread{ private String name; private int maxSize; private Queue\u003cBug\u003e queue; private Lock lock; private Condition noFull; private Condition noEmpty; /** * 构造方法 * @param name * @param queue * @param maxSize */ public Producer(String name, Queue\u003cBug\u003e queue, int maxSize, Lock lock, Condition noFull, Condition noEmpty){ this.name = name; this.maxSize = maxSize; this.queue = queue; this.lock = lock; this.noFull = noFull; this.noEmpty = noEmpty; } /** * 重写run方法,来不断生产bug到队列中 */ @Override public void run() { Random random = new Random(); while(true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //生产者不断生产bug Bug bug = this.produceBug(random.nextInt()); //模拟耗时操作 //加锁,避免并发问题 lock.lock(); try{ while(queue.size() == maxSize){ //当前的队列已满,无法将bug放进去,那么就等待,直到被唤醒(消费者会来唤醒的) try { System.out.println(\"[\" + name + \"]: 当前系统的Bug达到上限,歇会儿,不满的时候跟俺说一声~\"); //在noFull条件上等待,等待不为满的时候将其唤醒 noFull.await(); } catch (InterruptedException e) { e.printStackTrace(); } } //现在可以把bug放进去了 queue.add(bug); System.out.println(\"[\" + name + \"]: 俺往系统里面放了一个Bug\" + bug.getBugId() + \",嘿嘿~嘿嘿嘿~\"); //唤醒在睡眠的消费者(当时那些消费者消费的时候发现队列为空,就在noEmpty条件变量上等待,现在我刚放进去一个bug,队列肯定不为空,所以唤醒他们) noEmpty.signalAll(); }finally { //解锁 lock.unlock(); } } } /** * * 生产者生产一个带编号的Bug(可真是和我一模一样呢) * @param i * @return */ public Bug produceBug(int i){ Bug bug = new Bug(i); return bug; } } Consumer类 package ProAndCon; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; /** * @author TheR1sing3un * @date 2022/1/9 17:32 * @description 消费者 */ public class Consumer extends Thread{ private String name; private Queue\u003cBug\u003e queue; private Lock lock; private Condition noFull; private Condition noEmpty; public Consumer(String name, Queue\u003cBug\u003e queue, Lock lock, Condition noFull, Condition noEmpty) { this.name = name; this.queue = queue; this.lock = lock; this.noEmpty = noEmpty; this.noFull = noFull; } /** * 重写run方法,消费者从队列中拿Bug,然后去修复(消费者就是修复Bug的可怜程序员) */ @Override public void run() { while (true){ //操作队列就要上锁! lock.lock(); try{ while (queue.isEmpty()){ //当队列中没有Bug时,就等待 try { System.out.println(\"[\" + name + \"]: 这系统做的可以,咋没Bug,整挺好,我摸鱼去了,有Bug叫我\"); //当前队列为空,需要等待不为空的时候继续,于是在noEmpty上等待 noEmpty.await(); } catch (InterruptedException e) { e.printStackTrace(); } } //有bug时取出 Bug bug = queue.poll(); //模拟耗时操作 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } fixBug(bug); //唤醒在noFull上等待的生产者,因为刚刚该线程才消费了,目前肯定不满了 noFull.signalAll(); }finally { //解锁 lock.unlock(); } } } /** * 消费者修复Bug * @param bug */ public void fixBug(Bug bug){ System.out.println(\"[\" + name + \"]: 修复了Bug\" + bug.getBugId()); } } Test测试 package ProAndCon; import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @author TheR1sing3un * @date 2022/1/9 17:41 * @description */ public class Test { public static void main(String[] args) { Queue\u003cBug\u003e queue = new LinkedList\u003c\u003e(); Lock lock = new ReentrantLock(); Condition noFull = lock.newCondition(); Condition noEmpty = lock.newCondition(); int maxSize = 5; for (int i = 0; i \u003c 10; i++) { new Producer(\"新手程序员\"+i+\"号\",queue,maxSize,lock,noFull,noEmpty).start(); } for (int i = 0; i \u003c 10; i++) { new Consumer(\"老手程序员\"+i+\"号\",queue,lock,noFull,noEmpty).start(); } } } 测试截图： ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:3:1","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"BlockingQueue BlockingQueue，人称阻塞队列，是一个线程安全的容器，而且其内部结合了AQS的Lock和Condition，来保证从中取的时候，如果没有元素会被阻塞直到不为空；往里面放的时候，如果队列满了也会阻塞直到不满。 那这就简单了，我们就只需要从这个容器取/放，其他的交给它来。 ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:4:0","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"代码实例 Bug类(不再贴了) Producer类 package ProAndCon2; import ProAndCon.Bug; import java.util.Random; import java.util.concurrent.BlockingDeque; /** * @author TheR1sing3un * @date 2022/1/9 22:58 * @description */ public class Producer extends Thread{ private String name; private BlockingDeque blockingDeque; public Producer(String name, BlockingDeque blockingDeque){ this.name = name; this.blockingDeque = blockingDeque; } /** * 重写run方法,来不断生产bug到队列中 */ @Override public void run() { Random random = new Random(); while(true){ try { //模拟耗时操作 Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } //生产者不断生产bug ProAndCon.Bug bug = this.produceBug(random.nextInt()); //往阻塞队列里面放 try { blockingDeque.put(bug); System.out.println(\"[\" + name + \"]: 俺往系统里面放了一个Bug\" + bug.getBugId() + \",嘿嘿~嘿嘿嘿~\"); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * * 生产者生产一个带编号的Bug(可真是和我一模一样呢) * @param i * @return */ public ProAndCon.Bug produceBug(int i){ ProAndCon.Bug bug = new Bug(i); return bug; } } Consumer类 package ProAndCon2; import ProAndCon.Bug; import java.util.Random; import java.util.concurrent.BlockingDeque; /** * @author TheR1sing3un * @date 2022/1/9 23:00 * @description */ public class Consumer extends Thread{ private String name; private BlockingDeque\u003cBug\u003e blockingDeque; public Consumer(String name, BlockingDeque blockingDeque) { this.name = name; this.blockingDeque = blockingDeque; } /** * 重写run方法,消费者从队列中拿Bug,然后去修复(消费者就是修复Bug的可怜程序员) */ @Override public void run() { while (true){ //从阻塞队列中取bug Bug bug = null; try { bug = blockingDeque.take(); } catch (InterruptedException e) { e.printStackTrace(); } try { //模拟耗时操作 Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } fixBug(bug); } } /** * 消费者修复Bug * @param bug */ public void fixBug(Bug bug){ System.out.println(\"[\" + name + \"]: 修复了Bug\" + bug.getBugId()); } } Test测试 package ProAndCon2; import java.util.concurrent.BlockingDeque; import java.util.concurrent.LinkedBlockingDeque; /** * @author TheR1sing3un * @date 2022/1/9 17:41 * @description */ public class Test { public static void main(String[] args) { BlockingDeque\u003cBug\u003e blockingDeque = new LinkedBlockingDeque\u003c\u003e(10); for (int i = 0; i \u003c 10; i++) { new Producer(\"新手程序员\"+i+\"号\",blockingDeque).start(); } for (int i = 0; i \u003c 10; i++) { new Consumer(\"老手程序员\"+i+\"号\",blockingDeque).start(); } } } 测试截图： ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:4:1","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"总结 上述就是三种实现简易的生产者消费者模型的方法，实际中比较少用Java中的生产者消费者模型，更多的使用消息队列来当作一种生产者消费者模型。主要是理解这个多线程间通信和生产者消费者模式的特性。 ","date":"2022-01-09","objectID":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/:5:0","tags":["Java","多线程","面试"],"title":"Java实现生产者消费者模型","uri":"/java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"LRU算法原理及实现 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:0:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"前言 什么是LRU算法？ LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 那么该数据结构就是当存储队列到达上限时，清除的是最久未被访问的节点，该节点一般认为是最可能无用的节点，保留下来的是最近都有使用过的节点，因此可以实现对\"有用\"数据的最大程度保留。 LRU算法应用场景？ LRU算法有许多的应用场景。 Redis中使用LRU来进行淘汰 操作系统底层的内存管理，比如说页面置换算法中的LRU算法 业务处理，比如说做一个用户最近10个浏览记录，那么就可以使用LRU算法来维护一个大小为10的LRU队列 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:1:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"原理 LRU算法需要实现如下特性 实现get/put方法(都为O(1)的时间复杂度) 每次get时需要将访问的节点提前至队首 每次put需要判断队列是否已满，满了则将最后的节点删除，并且将该节点放至队首，不满则直接放队首 基于上述特性需要实现如下数据结构 首先需要实现队列，如果使用单向链表，当我们需要使用删除操作时，需要获得前置节点的指针，单向链表则不能做到直接获取。因此使用双向链表。 又我们需要get方法达到O(1)的时间复杂度，因此需要一个Hashmap，可以根据key定位到我们双向链表的Node节点。 由于我们HashMap中有key，所以我们可不可以Node中只存value，其实是不可以的，后续会提到这个原因。 因此我们实现了如下数据结构 双向链表+HashMap的数据结构HashLinkedList \"\r双向链表+HashMap的数据结构\r 缓存淘汰过程如下 LRU缓存淘汰过程LRU算法缓存淘汰策略- Mr.Ming2 - 博客园 \"\rLRU缓存淘汰过程\r ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:2:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"实现 那么现在我们就开始实现一个简易的LRU算法 首先需要实现一个Node节点 public class Node { //Node中存键值对 public int key,val; //前置节点和后置节点 public Node next,pre; public Node (int key,int val){ this.key = key; this.val = val; } } 接下来实现一个关于Node节点的双向链表以及相关方法 需要有头尾节点 有大小size 实现addFirst()/removeLast()/remove()/size()方法 /** * @author TheR1sing3un * @date 2021/12/30 11:14 * @description 双向链表数据结构实现 */ public class DoubleList { //头节点和尾节点 private Node head,tail; //大小 private int size; /** * 构造方法并且完成首尾节点初始化 */ public DoubleList (){ head = new Node(0,0); tail = new Node(0,0); head.next = tail; tail.pre = head; } /** * 添加一个节点到队首 * @param node */ public void addFirst(Node node){ node.pre = head; node.next = head.next; head.next.pre = node; head.next = node; size++; } /** * 删除最后一个节点 * @return 返回被删除的节点 */ public Node removeLast(){ //没有节点时候,返回null if (head.next == tail) return null; Node last = tail.pre; last.pre.next = tail; tail.pre = last.pre; size--; return last; } /** * 删除某个节点 * @param node * @return 返回被删除的节点 */ public Node remove(Node node){ node.pre.next = node.next; node.next.pre = node.pre; size--; return node; } /** * 获取当前链表大小 * @return 链表大小 */ public int size(){ return size; } /** * 打印该链表 */ public void print(){ Node cur = head.next; while(cur != tail){ System.out.print(cur.key+\"-\u003e\"+ cur.val+\" \"); cur = cur.next; } System.out.println(); } } 接下来实现LRU队列 需要有一个HashMap完成key-\u003eNode的映射 需要有一个DoubleList来存放Node节点 有容量上限cap 使用私有的delete()/removeLast()/makeFirst()/addFirst()来辅助put()和get()方法，避免直接操作node 有put()/get()/size()方法 /** * @author TheR1sing3un * @date 2021/12/30 11:49 * @description LRU队列实现 */ public class LRUCache { //key-\u003enode的映射 private HashMap\u003cInteger,Node\u003e map; //双向链表作为缓存队列 private DoubleList cache; //最大容量 private int cap; //构造方法,并且完成map和list的初始化 public LRUCache(int cap){ this.cap = cap; map = new HashMap\u003cInteger,Node \u003e(); cache = new DoubleList(); } /** * 删除某个key对于的键值对 * @param key */ private void delete(int key){ //从map中获取该节点 Node node = map.get(key); //从链表删除该节点 cache.remove(node); //从map中删除该key map.remove(key); } /** * 删除缓存队列中最后一个节点,也就是最久未被使用的节点 */ private void removeLast(){ //从链表中删除该节点 Node node = cache.removeLast(); //根据该节点的key来删除map中对应的键值对 map.remove(node.key); //此处也就是为什么我们需要Node中存key的原因,因为需要根据key来删除map中的键值对 } /** * 将某个键提前到队首,也就是变成最近使用的节点 * @param key */ private void makeFirst(int key){ //从map中获取该节点 Node node = map.get(key); //删除该节点 cache.remove(node); //将该节点重新插入到队首 cache.addFirst(node); } /** * 添加一个键值对到队首,也就是到最近使用的位置 * @param key * @param val */ private void addFirst(int key,int val){ Node node = new Node(key,val); //添加到队首 cache.addFirst(node); //添加映射 map.put(key,node); } /** * 暴露出来的put()方法,向LRUCache中插入一个键值对,若key已存在则更新 * @param key * @param val */ public void put(int key,int val){ if (map.containsKey(key)){ //若key已存在,那么需要先删除旧数据 delete(key); //插入到队首 addFirst(key,val); return; } //当达到容量上限时 if(cache.size() == cap){ //删除最久未被使用的节点 removeLast(); } //添加到队首 addFirst(key,val); } /** * 暴露出来的get()方法,根据key获取到val,若不存在,则返回-1(假定val都为正整数) * @param key */ public int get(int key){ if (!map.containsKey(key)){ //key不存在 return -1; } //将该key移动到队首,也就是最近使用的第一个 makeFirst(key); //返回值　 return map.get(key).val; } /** * 暴露出来的size()方法,返回当前的大小 * @return 返回当前队列大小 */ public int size(){ return cache.size(); } /** * 打印缓存队列 */ public void print(){ cache.print(); } } ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:3:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"测试 public class Test { public static void main(String[] args) { LRUCache lruCache = new LRUCache(5); Scanner sc = new Scanner(System.in); int key,val; while(true){ System.out.println(\"请输入插入的key和val(以空格隔开,输入-1则结束)\"); key = sc.nextInt(); if (key == -1) break; val = sc.nextInt(); lruCache.put(key,val); lruCache.print(); } while(true){ System.out.println(\"请输入需要获取的key(输入-1则结束)\"); key = sc.nextInt(); if (key == -1) break; System.out.println(\"key-\u003eval: \"+key+\"-\u003e\"+lruCache.get(key)); lruCache.print(); } } } 自行输入测试image-20211230132907832 \"\r自行输入测试\r 至此，我们就完成了一个简易的LRU算法，除此之外，我们还可以使用Java中自带的api来简化LRU实现 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:4:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"LRU(使用LinkedHashMap) LinkedHashMap内部数据结构就是一条双向链表+HashMap，因此我们可以不用自己定义这些数据结构，具体实现交给LinkedHashMap，我们只需要处理put()/get()方法即可。 /** * @author TheR1sing3un * @date 2021/12/30 13:35 * @description 使用LinkedHashMap实现的LRU */ public class LRUCacheSimple { private int cap; private LinkedHashMap\u003cInteger,Integer\u003e cache = new LinkedHashMap(); public LRUCacheSimple(int cap){ this.cap = cap; } /** * 将某个键改成最近使用的 * @param key */ private void makeRecently(int key){ //先获取值 Integer val = cache.get(key); //删除该键 cache.remove(key); //重新插入 cache.put(key,val); } /** * 插入key,val * @param key * @param val */ public void put(int key,int val){ if (cache.containsKey(key)){ //如果已存在,那么覆盖 cache.put(key,val); //将key变成最近使用 makeRecently(key); return; } if (cap \u003c= cache.size()){ //当满了之后 //获取第一个key(也就是LinkedHashMap中最久未被访问的节点) Integer first = cache.keySet().iterator().next(); //删除该节点 cache.remove(first); } //将新的key,val插入 cache.put(key,val); } /** * 根据key获取value(假定value都是正整数) * @param key * @return value(-1表示不存在) */ public int get(int key){ if (!cache.containsKey(key)){ return -1; } //将该key变成最近使用的 makeRecently(key); return cache.get(key); } /** * 打印该缓存 */ public void print(){ Iterator\u003cInteger\u003e iterator = cache.keySet().iterator(); while(iterator.hasNext()){ int key = iterator.next(); System.out.print(key+\"-\u003e\"+ cache.get(key)+\" \"); } System.out.println(); } } ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:5:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"LRU(GoLang实现) 上述是Java版本的LRU实现，下述我使用Golang语言进行实现，大致思路和逻辑是相同的。 代码如下 package LRU import \"fmt\" type Node struct { key int val int pre *Node next *Node } type LRUCache struct { Cap int //最大容量 bucket map[int]*Node //HashMap head *Node tail *Node Size int } //LRUCache的构造 func New(cap int) *LRUCache { cache := \u0026LRUCache{ Cap: cap, bucket: make(map[int]*Node, cap), head: \u0026Node{0, 0, nil, nil}, tail: \u0026Node{0, 0, nil, nil}, Size: 0, } cache.head.next = cache.tail cache.tail.pre = cache.head return cache } //添加一个节点到首位(也就是最近一个访问的) func (this *LRUCache) addNodeFirst(node *Node) { //判断是否到容量上限 if this.Size == this.Cap { //到达上限之后,删除最后一个节点 this.deleteNode(this.tail.pre) } //添加节点到首位 node.pre = this.head node.next = this.head.next this.head.next.pre = node this.head.next = node //添加该映射 this.bucket[node.key] = node this.Size++ } //将某个key变成最近使用的(假定该key一定存在) func (this *LRUCache) makeNodeFirst(key int) { //根据key获取该节点 node := this.bucket[key] //先删除该节点 this.deleteNode(node) //再加入该节点到首位 this.addNodeFirst(node) } //删除某个节点 func (this *LRUCache) deleteNode(node *Node) { //先删除映射 delete(this.bucket, node.key) //从双向链表中删除该节点 node.pre.next = node.next node.next.pre = node.pre this.Size-- } //put方法 func (this *LRUCache) Put(key, val int) { //先判断是否已有该节点,有则更新 node := this.bucket[key] if node == nil { //当没有该节点时,直接加入到首位 node := \u0026Node{key, val, nil, nil} this.addNodeFirst(node) } else { //如果已经有该节点,那么先直接更新该节点的值并且提前至首位 node.val = val this.makeNodeFirst(key) } } //get方法,如果不存在则返回-1(假设值都是正数) func (this *LRUCache) Get(key int) int { node := this.bucket[key] if node == nil { //不存在则返回-1 return -1 } else { //将节点提前到首位 this.makeNodeFirst(key) //返回值 return node.val } } func (this *LRUCache) Print() { cur := this.head.next for ; cur != this.tail; cur = cur.next { fmt.Printf(\"%d-\u003e%d \", cur.key, cur.val) } fmt.Println() } 测试代码如下 package LRU import ( \"fmt\" \"testing\" ) func TestLRUCache_New(t *testing.T) { cache := New(5) for i := 1; i \u003c 8; i++ { fmt.Printf(\"加入节点%d\\n\", i) cache.Put(i, 11*i) cache.Print() } fmt.Printf(\"查询节点%d ,值为%d\\n\", 3, cache.Get(3)) cache.Print() fmt.Printf(\"查询节点%d ,值为%d\\n\", 6, cache.Get(6)) cache.Print() fmt.Printf(\"查询节点%d ,值为%d\\n\", 7, cache.Get(7)) cache.Print() } ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:6:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"优化 上述的LRU容器还是一个根本不能投入生产使用的玩具级实现，可以在进一步进行优化。 值的类型 上述的实现我们都是默认value是int，而且是正整数的int，然而生产中，不应该使用固定的value值。Java中应该使用泛型，GoLang中可以使用interface。 最大容量 上述我们的容器最大容量的单位是键值对的个数，这是不太合理的，因为实际中我们应该限制的是缓存占用大小，因此可以将最大限制改成byte为单位，而且需要对淘汰算法进行优化，这时候我们可能超出容量后，需要淘汰的不止是一个缓存，可以是多个，直到当前已用内存小于最大内存。 并发安全 上述我们写的只能在单线程下使用，没有考虑到并发问题，那么其实只需要对每次链表和队列的写查进行相应的加锁即可。Java可以使用synchronized关键字也可以使用ReentrantLock/ReentrantReadWriteLock来对其加锁。GoLang可以使用标准库的sync.Mutex来加锁。 其他 我们这次写的是每次都更新到首位的LRU，称为lru-1，也有lru-k的方式，这个需要根据情况进行优化。 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:7:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"优化后代码 针对上述的几个问题，我写了一个GoLang的优化后的LRU算法(仍然是lru-1) package lru import ( \"container/list\" \"fmt\" ) type Cache struct { //缓存队列最大缓存大小 maxBytes int64 //缓存队列目前已经使用大小 usedBytes int64 //链表 cacheList *list.List //map映射key-\u003eElement cacheMap map[string]*list.Element //删除记录时的回调函数 OnEvicted func(key string, value Value) } //键值对类型 type entry struct { key string value Value } //缓存的值的类型 type Value interface { //返回Value的内存大小 Len() int } //实例化函数 func New(maxBytes int64, onEvicted func(string, Value)) *Cache { return \u0026Cache{ maxBytes: maxBytes, usedBytes: 0, cacheList: list.New(), cacheMap: make(map[string]*list.Element), OnEvicted: onEvicted, } } //查找 func (c *Cache) Get(key string) (Value, bool) { //先从map里查找是否有该值 if element, ok := c.cacheMap[key]; ok { //若有则将该提至最近使用的 c.cacheList.MoveToFront(element) //返回(将element的value强转成自定义的Value类型 e := element.Value.(*entry) return e.value, true } return nil, false } //删除最久未被使用的节点 func (c *Cache) RemoveOldest() { //获取最后一个节点 cur := c.cacheList.Back() if cur != nil { //从list中删除 c.cacheList.Remove(cur) //从map中删除 entry := cur.Value.(*entry) delete(c.cacheMap, entry.key) //更新当前已用内存 c.usedBytes -= int64(len(entry.key)) + int64(entry.value.Len()) //运行回调函数 if c.OnEvicted != nil { c.OnEvicted(entry.key, entry.value) } } } //添加缓存 func (c *Cache) Put(key string, value Value) { //判断当前是否已经有该key if element, ok := c.cacheMap[key]; ok { //已经有该节点,则将该节点更新并移至队首(最近访问) c.cacheList.MoveToFront(element) entry := element.Value.(*entry) //更新当前已用内存(加上当前新增的value大小再减去原本的value大小) c.usedBytes += int64(value.Len()) - int64(entry.value.Len()) //更新值 entry.value = value } else { //若不存在,则添加至队首,并更新map element := c.cacheList.PushFront(\u0026entry{key, value}) //添加至map c.cacheMap[key] = element //更新已用内存 c.usedBytes += int64(len(key)) + int64(value.Len()) } //添加之后判断是否已经超过最大内存(当最大内存不为0时而且已用内存超过最大内存时删除最近未使用的节点) for c.maxBytes != 0 \u0026\u0026 c.maxBytes \u003c c.usedBytes { c.RemoveOldest() } } //获取当前缓存的数据条数 func (c *Cache) Len() int { return c.cacheList.Len() } func (c *Cache) Print() { for cur := c.cacheList.Front(); cur != nil; cur = cur.Next() { kv := cur.Value.(*entry) fmt.Printf(\"%s-\u003e%s \", kv.key, kv.value) } fmt.Println() } package gocache import ( \"github.com/TheR1sing3un/gocache/gocache/lru\" \"sync\" ) type cache struct { //互斥锁 lock sync.Mutex //lru缓存队列 lru *lru.Cache //最大缓存大小 cacheBytes int64 } //缓存put方法 func (c *cache) put(key string, value ByteView) { c.lock.Lock() defer c.lock.Unlock() if c.lru == nil { //懒加载lru c.lru = lru.New(c.cacheBytes, nil) } c.lru.Put(key, value) } //缓存get方法 func (c *cache) get(key string) (value ByteView, ok bool) { c.lock.Lock() defer c.lock.Unlock() if c.lru == nil { //还未初始化(当前肯定没有数据) return } if value, ok := c.lru.Get(key); ok { return value.(ByteView), true } return } ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:7:1","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"总结 至此，我们就完成了三种手写LRU算法，不需要过多练习，只需要记住核心思想就是每次get时候我就提前，每次put也要提前，并且需要判断是否满载，若满则删除最后的(最久未被访问的节点)。 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:8:0","tags":["算法","Java","面试","GoLang"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["杂文"],"content":"我的大二\"秋招\"之旅 ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:0:0","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"前言 昨天看到了室友(友链中第一个，很强的大佬)写了一篇《我的大二\"秋招\"总结》,我也感同身受，也写一篇关于我的大二\"秋招\"滑铁卢记录史 ​ 从今年(2021)五月份开始下定决心走后端开发的道路，到现在也已经学习了有整整7个月了，虽然自己学的时间比较短，但是鉴于每天都花了不少的时间，综合来看，还算达到了自己当初的一个预期吧。 ​ 比较幸运的是自己一路上成长都没有遇到什么太大的坎坷，一路上都有在朋友的建议和个人的规划下慢慢成长。暑假和室友关于寒假去不去实习的问题讨论了很久，我那时候还很犹豫，因为我那时候我才接触后端开发3个月，项目只跟着视频做了个很简单的博客系统，更别谈计算机基础课/八股文/算法了。但是随着我8月份进入了为之工作室之后，感觉自己成长速度快了起来，做了几个小项目，看了不少技术类的书籍，认识了不少厉害的学长，从他们那里学到了许多自己不知道的知识。因此自己也有了尝试去面试的想法，特别是在室友的反复熏陶之下，竟然都敢有面中大厂的心思了。 这是我当时八月份定下来的一些小目标，除了入职其他的已经超出我的预期达到了 这也是我八月份给2021年剩下的四个月定下的目标，没想到我在10月末就完成了许多，剩下的部分如果没有可恶的期末考😣，估计我也可以粗略的完成了吧(算法除外😪) ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:1:0","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"开始投递 ​ 当时间来到十月底，也就是10月30号，特地挑了我生日这天，我和我的室友连麦开始投递了几家公司的实习岗位，那时候我还非常有仪式感的在售货机买了瓶阿萨姆奶茶大牌子。 ​ 当时第一批投递的几家公司image-20211210180259929 \"\r当时第一批投递的几家公司\r ​ 投完之后，我激动了改了自己的QQ个性签名如同小学生的QQ签名IMG_20211210_183502 \"\r如同小学生的QQ签名\r 不出所料，上述的四家公司，我没有一家拥有面试机会，果然还是简历不够优秀啊(也许也是对于大二学生一种天然的不看好) ​ 但是好在我在11.1号，从超强学长yxr那里加上了Momenta的HR小姐姐(确实很漂亮🤣)，于是我就拥有了人生中第一次面试的经历(工作室面试除外，得益于超强学长xpf的放水嘿嘿😁)。 ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:2:0","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"Momenta ​ 11.1上午才加的HR，没想到立马把面试约到了晚上7点，我赶紧一波临时抱佛脚，请教了几个同样面试了该公司并且已经oc的学长，下午便匆匆忙忙去面了。 ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:3:0","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"一面问题 Momenta一面问题 回答思路 学了数据结构吗？讲一讲常见的数据结构 讲了栈、堆、队列，扩展了Java中PriorityQueue的底层数据结构 现在有一颗多叉树，你怎么存进数据库呢？ 用一个字段记录父节点，引出我之前写的项目的多级评论的实现也是一颗多叉树 Java怎么实现生产者消费者模型 1.BlockingQueue 2.sync+wait+notify 3.lock+await+signal 分治算法和动态规划的异同点 都是将一个大问题分成一个个小问题，但是分治算法的小问题之间独立，而动态规划的小问题之间是有关系的 Redis怎么实现分布式锁？ 使用setnx进行加锁，key是锁名，value是一个类似于UUID，时间戳也可以，解锁的时候，写一个lua脚本进行解锁，判断value是不是自己设进去的那个，防止将别人的加的锁给删除了。 持有锁的线程挂掉怎么办？ 设置过期时间，防止死锁。扩展了下，如果是Redis的master拿到锁，但是还没同步给salve就挂掉了，那么这时候就可以被重复加锁了，那么就需要使用RedLock来解决 计网分层模型 OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；普遍理解的四层模型：物理接口层、网络层、传输层、应用层 能实习多久？ 三个月以上 学校的课怎么办？ 自学 ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:3:1","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"面试通过 ​ 一面的问题并不难，但是总共只面了29分钟，而且没有问我项目，一度感觉自己凉了，再加上面之前HR说这个面试官是刷人机器，让我一度很紧张。晚上忍不住问了HR，没想到过了，而且只有一面，直接发Offer。🤑 ​ 第二天就开心的接到了HR的电话，并且开心了收到了Offer邮件 Momenta的Offer邮件image-20211211120015672 \"\rMomenta的Offer邮件\r ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:3:2","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"字节跳动 ​ 由于自己还是一路太顺，第一次面试就拿下了Offer，于是有点飘飘然了，就和室友一起开始投了其他的中大厂。百度投了之后，很快就打电话问个人情况，然后就杳无音讯了(本来也不想去百度)。秉承着对工作室学长学姐们的传承精神(好多学长学姐大二都去过字节了🤓)，我对字节十分的向往。字节投了好几个地方，从牛客到实习僧还有内推码，都投了个遍。接下来就开始漫长的等待了。 ​ 11.25那天接到了抖音音乐的电话，确认了下基本情况，还问了问我可以接受转客户端吗。我已经苦苦等了十天，管它那么多，有面试机会我就很知足了，于是就说了可接受。果不其然，在11.29号那天接到了电话，说我通过了简历筛选，是客户端岗位(早知道我就之前直接说不接受了，简历还被卡在抖音音乐这么久，可恶😩)。我直接拒绝，并且请求声音好听的HR小姐姐帮我简历解锁，让我赶紧有机会面下一家。 ​ 于是在12.1号，我接到了字节Data的面试通知，但是我没想到是推荐架构部门的，我一口答应了，并且约到了12.3的下午的面试。当我在12.2号晚上才看到是推荐架构的面试时，我就知道自己已经走错了一大步！☹ 字节的面试通知邮件image-20211210185049771 \"\r字节的面试通知邮件\r ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:4:0","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"一面问题 字节一面面试问题 回答思路 自我介绍 30秒说完，毕竟自己毫无亮点 能实习多久？ 四个月以上 你做的这个SpringCloud项目是自己做的还是学校的项目？ 自己构思然后找了个前端(友链里的🍅)一起做的 你这个项目用Redis做什么了？ 用来完成邮件验证码的过期时间，和前期部分的接口频率限制(zset实现) Redis和Mysql区别？ 一个是关系型一个是Nosql。Redis做分布式更好，Redis可以实现分布式锁和分布式缓存等等，Mysql一般用于更底层的数据存储，而且Redis有Mysql中无法完成的一些功能，比如redis的Geo可以做位置相关的一些功能，bitmap可以做布隆过滤器之类的 算法题:LeetCode：679 自己太菜了，而且第一次视频面试，很紧张，虽然面试官一直耐心提示，但是最后还是没完全写出来 Url从输入到显示的过程 老八股了，但是还是没答的很好，因为很多地方忘了(心理素质不行😓) Tcp/Udp区别分别什么使用场景 可靠性答了点，提到了现在的Udp也可以可靠连接了，基于quic那个。分别的使用场景讲了讲 一面反问问题 面试官回答 部门业务 推荐架构 技术栈 C++居多，也有Golang 还有什么需要改进的? 面试官说觉得我答得可以，作为大二已经很好了，但是还是让继续努力，学校的基础课可以好好学(潜台词：你这么菜就别出来实习了😵) ​ 面完我就知道自己基本凉了，在牛客发了面经，大家也都有说大二的这个程度已经很强了，但是我知道这和年级无关，我也有朋友大二就进字节了(参考友链的Attack204)。自己还是不行，得继续加油。 ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:4:1","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"一面不通过 ​ 经过了一个周末的苦苦等待，哪怕我已经知道了自己挂定了，但是还是抱有一丝希望。 ​ 周一11点就赶快联系了HR，HR立马一个电话过来，我还以为自己有戏了。HR说：一面面试官觉得你时间上不太允许来实习。我大概就知道了这是面试官安慰我呢，其实算法没写出来，基本就没有通过的机会了。(好像大部分人说实习一面出Hard的算法就是找个理由劝退，其实总的来说，不管是啥难度的题，没写出来就是能力不行) ​ 下午便收到了感谢信，然后后面陆续也有几个部门把我捞起来了，但是我觉得还是自己寒假好好学习，再认真准备一下暑假实习吧！ 字节感谢信image-20211210191532264 \"\r字节感谢信\r ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:4:2","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["杂文"],"content":"寒假期望 ​ 由于只有一家Momenta的Offer，然后听说上海那边是比996还猛，我为了身体健康还是选择不去了，而且寒假还是想在家里自己学一学，还可以陪家人过年，毕竟随着成长，以后回家的时间也越来越少了。就算去的话，下学期还得逃课，那么也就没啥时间准备二战字节了。😝 ​ 总的来说我的大二”秋招“之旅就这么结束了，还是有许多不甘，大二的身份让我连见到面试官的机会都基本没有。当然也是自己简历不够优秀。那也别在一次挫折中一蹶不振了，让自己兴奋起来，寒假认真准备，明年再卷土重来！🤩 ​ 寒假还是要给自己定下一些目标的，以防自己疯狂摸鱼。 寒假目标 学习Golang，掌握基本语法和常见框架 写100道算法题，高频题不能落下 产出10篇高质量的技术博客 刷穿字节面经 继续深度学习Mysql 学习操作系统 将八股文反复背背背 好好打球🏀 ","date":"2021-12-09","objectID":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/:5:0","tags":["面试","字节跳动"],"title":"大二\"秋招\"滑铁卢实录","uri":"/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E6%8B%9B%E6%BB%91%E9%93%81%E5%8D%A2%E5%AE%9E%E5%BD%95/"},{"categories":["Spring"],"content":"SpringCould学习 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:0:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"前言 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:1:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"版本选择 SpringCloud:Hoxtom.SR1SpringBoot:2.2.2RELEASECloudAibaba:2.1.0RELEASeJava:1.8Maven:3.5及以上Mysql:5.7及以上 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:1:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"模块构建 新建项目 选择maven创建 选择骨架 修改字符编码 都改成utf-8 注解生效激活 设置java编译版本 File Type过滤(将项目下显示的一些杂七杂八的文件过滤掉) 将src删掉 将pom.xml中加入如下 统一管理jar包版本 \u003c!--统一管理Jar包版本--\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e12\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e12\u003c/maven.compiler.target\u003e \u003cjunit.version\u003e4.12\u003c/junit.version\u003e \u003clombok.version\u003e1.18.10\u003c/lombok.version\u003e \u003clog4j.version\u003e1.2.17\u003c/log4j.version\u003e \u003cmysql.version\u003e5.1.47\u003c/mysql.version\u003e \u003cdruid.version\u003e1.1.16\u003c/druid.version\u003e \u003cmybatis.spring.boot.version\u003e1.3.0\u003c/mybatis.spring.boot.version\u003e \u003c/properties\u003e 编写dependencyManagement 作用: 统一声明版本号 升级时只需该父工程的pom.xml中的版本号就可以处处升级 子模块不用写版本号 如果子模块要使用别的版本，只用自己声明version \u003c!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--\u003e \u003cdependencyManagement\u003e\u003c!--定义规范，但不导入--\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-project-info-reports-plugin\u003c/artifactId\u003e \u003cversion\u003e3.0.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--spring boot 2.2.2--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud Hoxton.SR1--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eHoxton.SR1\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud 阿里巴巴--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.1.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--mysql--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e${mysql.version}\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- druid--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e${druid.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--mybatis--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${mybatis.spring.boot.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e${junit.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--log4j--\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e${log4j.version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e 增加热启动插件 \u003c!--热启动插件--\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cfork\u003etrue\u003c/fork\u003e \u003caddResources\u003etrue\u003c/addResources\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e maven中跳过单元测试 父工程创建完成后执行 mvn:install将父工程发布到仓库方便子工程继承 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"支付模块构建 构建微服务模块统一步骤 建module 改pom 写yml 主启动 业务类 创建支付模块 创建module，继承自父亲模块(maven无骨架创建) 改pom文件 把需要使用的pom文件导入 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.10\u003c/version\u003e \u003c/dependency\u003e \u003c!--mysql-connector-java--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--jdbc--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 改yml 在模块下的resources下新建application.yaml server:port:8001#服务端口号spring:application:name:cloud-payment-service#服务名称datasource:type:com.alibaba.druid.pool.DruidDataSource#当前数据源操作类型driver-class-name:org.gjt.mm.mysql.Driver#mysql驱动包url:jdbc:mysql://${person.mysql.host}:${person.mysql.port}/springcloud?useUnicode-true\u0026charcterEncoding=utf-8\u0026useSSL=falseusername:rootpassword:lcy021030person:mysql:host:49.234.111.177port:3306 主启动类 创建主启动类 业务类 数据库建表 CREATE TABLE `payment` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID', `serial` varchar(200) DEFAULT '', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 创建实体类 @NoArgsConstructor @AllArgsConstructor @Data public class Payment implements Serializable { private Long id; private String serial; } @Data @AllArgsConstructor @NoArgsConstructor public class CommonResult\u003cT\u003e { public static final Integer SUCCESS = 20000; public static final Integer ERROR = 40000; private Integer code; private String message; private T data; public static CommonResult ok(){ return new CommonResult(SUCCESS,\"success\",null); } public static CommonResult error(){ return new CommonResult(ERROR,\"error\",null); } public CommonResult msg(String message){ this.message = message; return this; } public CommonResult code(int code){ this.code = code; return this; } public CommonResult\u003cT\u003e data(T data){ this.data = data; return this; } } 编写PaymentDao层 编写PaymentMapper 文件头 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"pro.risingsun.springcloud.dao.PaymentDao\"\u003e \u003c/mapper\u003e 写Service 写controller postman自测 创建消费者模块 创建模块 写实体类(Payment和CommonResult) 使用RestTemplate RestTemplate 创建config.ApplicationContexConfig 将RestTemplate注册成bean 完善消费者的OrderConsumer ​ 测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"工程重构 将部分相似的代码进行重构整合 创建新模块cloud-api-commons 写pom 将entites移入 放入本地库 maven:clean maven:install 改造原本的两个模块的公共内容 删掉entities 在各自的pom文件中引入 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Eureka 一种服务注册中心，使用Eureka的客户端连接到到Eureka Server并维持心跳连接。这样就可以通过Eureka Server来监控系统的各个微服务是否正常运行 EurekaServer 提供注册服务，各个微服务节点通过配置启动后，会从EurekaServer中心进行注册。这样RurekaSever中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到 EurekaClient 一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的、使用轮询负载算法的负载均衡器。在应用启动后，将会用EurekaServer发送心跳(默认30秒为一个周期)。如果EurekaServer在多个心跳周期内没有接收到某个节点的心跳，EurekaServer就会从服务注册表中把这个服务节点移除(默认90秒) ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"IDEA创建EurekaServer 创建模块 改pom \u003cdependencies\u003e \u003c!--自定义的api通用包--\u003e \u003cdependency\u003e \u003cgroupId\u003epro.risingsun.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!--eureka-server--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 写yaml server:port:7001eureka:instance:hostname:localhost#eureka服务端的实例名称client:register-with-eureka:false#不注册自己fetch-registry:false#false表示自己就是注册中心,不需要去检索自己的服务service-url:#设置与EurekaServer交互的地址查询服务和注册服务都需要依赖这个地址defaultzone:http://${eureka.instance.hostname}:${server.port}/eureka/ 写启动类 ​ 打上注解@EnbaleEurekaServer表示自己是EurekaServer 测试 输入localhost:7001 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"将payment注册进Eureka中 改pom 增加EurekaClient的依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 改配置 eureka:client:#表示自己注册进EurekaServerregister-with-eureka:true#是否从EurekaServer抓取已有的配置信息,默认为true(单节点无所谓,集群必须设置为true才可以配置ribbon使用负载均衡)fetch-registry:trueservice-url:defaultZone:http://localhost:7001/eureka#EurekeServer的地址 改主启动类 加上注解@EnableEurekaClient 启动测试 这里的应用名称是我们在yaml文件中配置的,如下图: ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"将order注册进Eureka中 步骤如上，基本一致 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"集群Eureka搭建 互相注册，相互守望 创建cloud-eureka-server7002 参考7001进行创建 修改映射文件 写yaml 互相注册，相互守望 修改7001的配置文件 修改7002的配置文件 主启动类 测试访问eureka7001:7001 测试访问eureka7002:7002 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:4","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"将服务注册进集群 改配置文件 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:5","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"PaymentProvider集群搭建 参考8001搭建8002和8003 修改consumer的服务调用URL 但是这样消费者还是找不到是哪个生产者，因为三个生产者的服务名称都是cloud-payment-service，因此需要开启负载均衡 开启负载均衡 使用@LoadBalances注解赋予RestTemplate负载均衡能力 集群信息完善 增加实例名称 在payment8001和8002的配置文件中增加 增加ip显示 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:6","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"服务发现 对于注册进eureke里面的微服务，可以通过服务发现来获得该服务的信息 修改cloud-provider-payment8001的Controller 主启动类增加注解 测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:7","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Eureka自我保护 某时刻某一个微服务不可用了，Eureka不会立刻清理，仍旧会对该微服务的消息进行保存 属于CAP中的AP分支 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:8","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"ZooKeeper ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"创建payment 服务器上启动Zookeeper 新建模块cloud-provider-payment8004 改pom文件 将Eureka的依赖改成zookeeper的 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zookeeper-discovery\u003c/artifactId\u003e \u003c/dependency\u003e 改配置文件(将Eureka的改成Zookeeper) 主启动类 写Controller 测试localhost:8004/payment/zk ​ ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"创建order …省略 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Consul … ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:5:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Ribbon Ribbon是一套实现负载均衡的工具 spring-cloud-starter-netflix-eureka-client已经集成了Ribbon 如何替换负载均衡策略 该配置类不能放在@CompomentScan可以扫到的位置 主启动类增加注解 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:6:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"OpenFeign 用在消费端 创建模块cloud-consumer-feign-order9000 改pom \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003epro.risingsun.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!--eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--openfeign客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 改配置文件 server:port:9000spring:application:name:cloud-order-serviceeureka:client:register-with-eureka:truefetch-registry:trueservice-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版) 注册不注册都可以，消费端本来就不用注册 写主启动类 写服务调用接口 要点： 这里相当于是直接根据服务名和路径去服务端找相应的controller的方法，所以这里的服务名、路径、请求类型要一致才能在服务端找到方法 参数也要保证一致，而且需要打上相应的注解，没有SpringMVC帮忙封装了 负载均衡 自带负载均衡，使用Ribbon ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"OpenFeign超时控制 OpenFeign默认等待一秒钟 如果超过1秒种，Feign客户端直接报错 修改超时时间(OpenFeign自带Ribbon) ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"OpenFeign日志 日志级别: NONE：默认的，不显示任何日志 BASIC：仅记录请求方法、URL、相应状态码及执行时间 HEADERS：除了记录BASIC中定义的信息外，还有请求和相应的头信息 FULL：除了HEADERS中定义的信息外，还有请求和相应的正文及元数据 开启日志 创建日志配置类 配置文件中配置日志 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Hystix ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"重要概念 服务 降级 fallback 出现情况 程序运行异常 超时 服务熔断出发服务降级 线程池/常量池打满 服务熔断 当达到最大服务访问时，直接拒绝访问，然后调用服务降级 服务限流 限制服务访问 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 创建生产者 新建模块cloud-provider-hystrix-payment8005 pom文件 \u003c!--hystrix依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix\u003c/artifactId\u003e \u003c/dependency\u003e 写配置文件 写主启动类 写Service 写Controller 测试 创建消费者 … service，远程调用 controller 服务降级 服务提供方降级 激活服务降级功能 在主启动类上加上注解@EnbaleCircuitBeaker 使用注解@HystrixComman在业务方法上标记 服务消费方降级 改yml 改启动类 业务上处理 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"全局服务降级 现在的降级方式和业务代码耦合严重，而且重复冗余。那么需要进行全局的一个服务降级配置 @DefaultProerties(defaultFallback = “xxx”)设置默认的服务降级配置 如果某个方法有自己的配置，就用自己的，没有就用默认的 在Feign接口进行统一处理 写一个类实现PaymentFeignService接口，对方法进行重写 配置fallback ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"服务熔断 生产方Service代码如下 在错误了一定次数内失败率达到了设定值，那么进入熔断状态，然后在一定时间后(默认是5秒)会放出几个请求进去，如果还是错误降级了，那么就保持熔断状态，刷新休眠窗口期。如果请求正确了，那么熔断取消，正常运行。 参考链接 https://blog.csdn.net/loushuiyifan/article/details/82702522 参数说明 请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。 快照时间窗：断路器通过在统计一定时间内的请求和错误等数据决定是否开启熔断，而统计的时间范围就是快照时间窗，默认就是最近10秒 错误百分比阈值，当请求总数在快照时间窗内超过了阈值，而且错误请求的次数占的百分比超过了该错误百分比阈值，那么就会将断路器打开 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:4","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"监控页面 建模块 改pom 增加： \u003c!--hystrix仪表盘图形化页面--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix-dashboard\u003c/artifactId\u003e \u003c/dependency\u003e 改yml 写主启动类 启动，访问localhost:9001/hystrix 修改8005 监控8005 访问监控网址，测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:5","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"GateWay ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"入门配置 创建模块 改pom \u003c!--gateway网关--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e \u003c/dependency\u003e 写yml server:port:9527spring:application:name:cloud-gatewayeureka:instance:hostname:cloud-gateway-serviceclient:register-with-eureka:truefetch-registry:trueservice-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版) 写主启动类 写配置 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"动态路由 配置文件配置 server:port:9527spring:application:name:cloud-gatewaycloud:gateway:discovery:locator:enabled:true#开启从服务注册中心中动态创建路由的功能,利用微服务名进行路由routes:- id:payment_routh#配置路由的id,没有固定规则,但是要求唯一uri:lb://cloud-payment-service#匹配后提供的服务地址predicates:- Path=/payment/**#断言,根据路径进行路由##################- id:payment_routh2uri:lb://cloud-payment-service#匹配后提供服务的地址predicates:- Path=/service#断言,根据路径进行路由eureka:instance:hostname:cloud-gateway-serviceclient:#表示自己注册进EurekaServerregister-with-eureka:true#是否从EurekaServer抓取已有的配置信息,默认为true(单节点无所谓,集群必须设置为true才可以配置ribbon使用负载均衡)fetch-registry:trueservice-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版) 访问localhost:9527/payment/1测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"常用Predicate 也就是常用的断言配置 After Route Predicate 请求时间在该时间之后可以匹配 在配置文件中配置 可以通过如下Api进行获得该格式的日期: 在该日期之前无法访问 该日期之后可以访问 Before Route Predicate 请求的时间在这个时间之前可以匹配 Between Route Predicate 请求时间在两个时间内，可以匹配 Cookie Route Predicate 匹配Cookie断言 需要两个参数，第一个是Cookie name，第二个是政策表达式 Gateway会去检验对应的Cookie的value是否符合正则表达式 配置Predicate Header Route Predicate 请求头中进行匹配 两个参数，一个是请求头名，一个是值 测试不匹配 测试匹配 Method Route Predicate Path Route Predicate Query Route Predicate ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Filter 自定义全局日志过滤器 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:4","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Config ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"服务端(连接github) 微服务统一配置 建模块cloud-config-center-3344 写pom 增加 \u003c!--配置中心--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-config-server\u003c/artifactId\u003e \u003c/dependency\u003e 写配置文件 主启动类 测试localhost:3344/master/config-dev.yml 如果连接失败，使用ssh方式连接，使用旧方法创建私匙，在github中添加，然后配置文件中改成ssh的地址 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"客户端(连接服务端) 创建模块cloud-config-client-3355 改pom \u003c!--配置中心客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-config\u003c/artifactId\u003e \u003c/dependency\u003e 写bootstrap.yml application.yml是用户级的资源配置 bootstrap.yml是系统级，优先级更高 写主启动类 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"客户端动态更新 服务端可以实时更新，但是客户端不能实时更新 引入监控依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e 配置文件暴露监控端点 在controller添加注解@RefreshScope ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Bus 什么是总线？ 在微服务架构的系统总，通常用使用轻量级的消息代理来构建一个公用的消息主题，并让系统中所有微服务的实例都连接上来，由于该主题中产生的消息会被所有实例监听和消费，所以称它为消费总线。在总线上的各个实例，都可以方便的广播一些需要其他连接到该主题上的实例都知道的消息 基本原理 ConfigClient实例都监听MQ中同一个topic(默认是SpringCloudBus)。当一个服务刷新数据的时候，它会把这个消息放入到Topic中，这样其他监听同一Topic的服务就能得到通知，然后去更新自身的配置 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:11:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 再创建一个cloud-config-client-3366，步骤略 设计 利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端配置 利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置 方法二更适合 服务端添加Rabbitmq \u003c!--整合rabbitmq的bus消息总线--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amqp\u003c/artifactId\u003e \u003c/dependency\u003e 增加rabbitmq的配置 增加暴露刷新配置的端点 3344和3355添加消息总线的支持 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amqp\u003c/artifactId\u003e \u003c/dependency\u003e rabbitmq:host:49.234.111.177port:5672username:lcypassword:lcy021030 发送请求POST: localhost:3344/actuator/bus-refresh完成自动更新 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:11:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Stream 驱动，屏蔽底层消息中间件的差异 应用程序通过inputs或者outputs来与SpringCloudStream中的binder对象交互 通过配置来绑定(binding)，而SpringCloudStream的binder对象负责与消息中间件交互 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 生产者 创建模块cloud-stream-rabbitmq-provider8801 写pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rabbit\u003c/artifactId\u003e \u003c/dependency\u003e 写yml server:port:8801spring:application:name:cloud-stream-providercloud:stream:bindings:# 服务的整合处理output:# 这个名字是一个通道的名称destination:studyExchange# 表示要使用的Exchange名称定义content-type:application/json# 设置消息类型，本次为json，文本则设置“text/plain”binder:rabbit1# 设置要绑定的消息服务的具体设置#可以配置多个底层MQ的配置binders:# 在此处配置要绑定的rabbitmq的服务信息；rabbit1:# 表示定义的名称，用于于binding整合type:rabbit# 消息组件类型environment:# 设置rabbitmq的相关的环境配置spring:rabbitmq:host:49.234.111.177port:5672username:lcypassword:lcy021030rabbitmq:host:49.234.111.177port:5672username:lcypassword:lcy021030eureka:client:service-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版)instance:instance-id:send-8801.com#在信息列表显示的主机名称lease-renewal-interval-in-seconds:2#设置心跳的时间(默认是30秒)lease-expiration-duration-in-seconds:5prefer-ip-address:true 写主启动类 写业务接口 消费者 新建模块cloud-stream-rabbitmq-consumer8802 写pom 写yml 写业务 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"重复消费 此时两个消费者是不同组的，都监听一个交换机，所以都会收到消息，因此我们需要将两个消费者放到同一个组中 自定义分组 如果我们不自定义分组，那么默认使用的是不同的分组，因此可以自定义选择分组 在8802和8803中加入分组，那么收到的就是将两个消费者监听在同一个组中，消息则只能被消费一次 此时两个消费者就轮询接受消息。 原理 其实就是rabbitmq中的fandout和direct，默认情况两个消费者是不同的队列，然后绑定到同一个交换机，那么我们生产者生产一个消息到交换机，就会被两个队列都拿到。 当我们配置了组名时，其实就是变成了同一个队列，那么生产的消息发送到交换机时，交换机只发了一条消息给队列，那么监听同一个队列的消费者，只有一个能消费到消息，默认是轮询消费 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Sleuth SpringCloudSleuth提供了分布式追踪的解决方案 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"搭建zipkin 下载jar包后直接启动 访问localhost:9411查看面板 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 cloud-provider8001添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e 改配置 在consumer做一样的依赖和配置 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":" 西安电子科技大学2020级本科在读 一个想写Golang的Javaer 首要目标是顺利毕业 远大目标是在35岁之前光荣退休 ","date":"2021-12-09","objectID":"/about/:0:0","tags":null,"title":"关于 TheR1sing3un","uri":"/about/"},{"categories":null,"content":"以下是我的朋友们 对底层比较执着的大佬兼我的舍友 🐧刘陶峰的个人博客 难得一遇的超级前端大哥 🍅大faga的个人博客 前端+ACM双修的神 🔮Littlechai的个人博客 算法竞赛大神和后端开发同届大佬 🏆Attack204的个人博客 ","date":"2021-12-09","objectID":"/friendship/:0:0","tags":null,"title":"我的朋友","uri":"/friendship/"},{"categories":["开发工具学习"],"content":"Linux下开发工具之Tmux","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"Tmux学习 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:0:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"一.什么是Tmux ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:1:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"1.1传统命令行 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称\"窗口\"），在里面输入命令。用户与计算机的这种临时的交互，称为一次\"会话\"（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 为了解决这个问题，会话与窗口可以\"解绑\"：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话\"绑定\"其他窗口。 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:1:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"1.2Tmux作用 将会话与窗口解绑的工具 功能 允许在单个窗口中，同时访问多个会话。 可以让新窗口接入已经存在的会话 允许每个会话有多个连接窗口，可以多人实时共享会话 支持窗口任意的垂直和水平拆分 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:1:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"二.基本用法 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"2.1安装 centos系统下的安装 sudo yum install tmux ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"2.2启动和退出 启动 tmux 启动Tmux窗口,底部有一个状态栏。状态栏左侧是窗口信息(编号和名称)，右侧是系统信息 退出 exit或者Ctrl + D ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"2.3前缀键 Tmux的快捷键需要前缀键进行唤醒，默认前缀键是 Ctrl + B。先按下前缀键，快捷键才会生效 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"三.会话管理 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.1新建会话 默认启动的Tmux窗口编号从0开始，我们可以自己给会话起名字 tmux new -s \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.2分离会话 分离会话 在Tmux窗口下，按住Ctrl + B D或者输入tmux detach，就会将当前会话和窗口分离，上面命令执行后，就会退出当前的Tmux窗口，但是后台仍在运行里面的会话和进程 查看所有会话 tmux ls ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.3接入会话 用于重新接入某个已经存在的会话 tmux attach -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.4杀死会话 tmux kill-session -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:4","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.5切换会话 tmux switch -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:5","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.6重命名会话 tmux rename-session -t \u003csession-name\u003e \u003cnew-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:6","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.7会话快捷键 Ctrl + B D：分离当前会话 Ctrl + B S：列出所有会话 Ctrl + B $：重命名当前会话 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:7","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"四.最简操作流程 新建会话tmux new -s \u003csession-name\u003e 在Tmux窗口运行所需的程序 按下快捷键Ctrl +B D将会话分离 下次使用时，重新连接到会话tmux attach-session -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:4:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"五.网格操作 Tmux可以将窗口分成多个窗格，每个窗格运行不同的命令 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.1划分窗格 tmux split-window #划分上下两个窗格 tmux split-window -h #划分左右两个窗格 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.2移动光标 使用tmux select-pane命令用来移动光标位置 tmux select-pane -U #光标切换到上方窗格 tmux select-pane -D #光标切换到下方窗格 tmux select-pane -L #光标切换到左边窗格 tmux select-pane -R #光标切换到右边窗格 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.3交换窗格位置 tmux swap-pane 命令来交换窗格位置 tmux swap-pane -U #当前窗格上移 tmux swap-pane -D #当前窗格下移 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.4窗格快捷键 Ctrl+b %：划分左右两个窗格。 Ctrl+b \"：划分上下两个窗格。 Ctrl+b \u003carrow key\u003e：光标切换到其他窗格。\u003carrow key\u003e是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。 Ctrl+b ;：光标切换到上一个窗格。 Ctrl+b o：光标切换到下一个窗格。 Ctrl+b {：当前窗格与上一个窗格交换位置。 Ctrl+b }：当前窗格与下一个窗格交换位置。 Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 Ctrl+b x：关闭当前窗格。 Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+\u003carrow key\u003e：按箭头方向调整窗格大小。 Ctrl+b q：显示窗格编号 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:4","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"六.窗口管理 Tmux允许新建多个窗口 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.1新建窗口 tmux new-window命令用来创建新窗口 tmux new-window #新建一个窗口 tmux new-wndow -n \u003cwindow-name\u003e #新建一个指定名称的窗口 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.2切换窗口 tmux select-window命令用来切换窗口 tmux select-window -t \u003cwindow-number\u003e #切换到指定编号的窗口 tmux select-window -t \u003cwidnow-name\u003e #切换到指定编号的窗口 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.3重命名窗口 tmux rename-window命令用于为当前窗口起名(或重命名) tmux rename-window \u003cnew-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.4窗口快捷键 Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。 Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。 Ctrl+b n：切换到下一个窗口。 Ctrl+b \u003cnumber\u003e：切换到指定编号的窗口，其中的\u003cnumber\u003e是状态栏上的窗口编号。 Ctrl+b w：从列表中选择窗口。 Ctrl+b ,：窗口重命名。 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:4","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"七.其他命令 # 列出所有快捷键，及其对应的 Tmux 命令 tmux list-keys # 列出所有 Tmux 命令及其参数 tmux list-commands # 列出当前所有 Tmux 会话的信息 tmux info # 重新加载当前的 Tmux 配置 tmux source-file ~/.tmux.conf ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:7:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"八.参考连接 https://www.ruanyifeng.com/blog/2019/10/tmux.html ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:8:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"}]
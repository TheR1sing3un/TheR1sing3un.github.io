[{"categories":["算法"],"content":"LRU算法原理及实现 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:0:0","tags":["算法","Java","面试"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"前言 什么是LRU算法？ LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 那么该数据结构就是当存储队列到达上限时，清除的是最久未被访问的节点，该节点一般认为是最可能无用的节点，保留下来的是最近都有使用过的节点，因此可以实现对\"有用\"数据的最大程度保留。 LRU算法应用场景？ LRU算法有许多的应用场景。 Redis中使用LRU来进行淘汰 操作系统底层的内存管理，比如说页面置换算法中的LRU算法 业务处理，比如说做一个用户最近10个浏览记录，那么就可以使用LRU算法来维护一个大小为10的LRU队列 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:1:0","tags":["算法","Java","面试"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"原理 LRU算法需要实现如下特性 实现get/put方法(都为O(1)的时间复杂度) 每次get时需要将访问的节点提前至队首 每次put需要判断队列是否已满，满了则将最后的节点删除，并且将该节点放至队首，不满则直接放队首 基于上述特性需要实现如下数据结构 首先需要实现队列，如果使用单向链表，当我们需要使用删除操作时，需要获得前置节点的指针，单向链表则不能做到直接获取。因此使用双向链表。 又我们需要get方法达到O(1)的时间复杂度，因此需要一个Hashmap，可以根据key定位到我们双向链表的Node节点。 由于我们HashMap中有key，所以我们可不可以Node中只存value，其实是不可以的，后续会提到这个原因。 因此我们实现了如下数据结构 双向链表+HashMap的数据结构HashLinkedList \"\r双向链表+HashMap的数据结构\r 缓存淘汰过程如下 LRU缓存淘汰过程LRU算法缓存淘汰策略- Mr.Ming2 - 博客园 \"\rLRU缓存淘汰过程\r ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:2:0","tags":["算法","Java","面试"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"实现 那么现在我们就开始实现一个简易的LRU算法 首先需要实现一个Node节点 public class Node { //Node中存键值对 public int key,val; //前置节点和后置节点 public Node next,pre; public Node (int key,int val){ this.key = key; this.val = val; } } 接下来实现一个关于Node节点的双向链表以及相关方法 需要有头尾节点 有大小size 实现addFirst()/removeLast()/remove()/size()方法 /** * @author TheR1sing3un * @date 2021/12/30 11:14 * @description 双向链表数据结构实现 */ public class DoubleList { //头节点和尾节点 private Node head,tail; //大小 private int size; /** * 构造方法并且完成首尾节点初始化 */ public DoubleList (){ head = new Node(0,0); tail = new Node(0,0); head.next = tail; tail.pre = head; } /** * 添加一个节点到队首 * @param node */ public void addFirst(Node node){ node.pre = head; node.next = head.next; head.next.pre = node; head.next = node; size++; } /** * 删除最后一个节点 * @return 返回被删除的节点 */ public Node removeLast(){ //没有节点时候,返回null if (head.next == tail) return null; Node last = tail.pre; last.pre.next = tail; tail.pre = last.pre; size--; return last; } /** * 删除某个节点 * @param node * @return 返回被删除的节点 */ public Node remove(Node node){ node.pre.next = node.next; node.next.pre = node.pre; size--; return node; } /** * 获取当前链表大小 * @return 链表大小 */ public int size(){ return size; } /** * 打印该链表 */ public void print(){ Node cur = head.next; while(cur != tail){ System.out.print(cur.key+\"-\u003e\"+ cur.val+\" \"); cur = cur.next; } System.out.println(); } } 接下来实现LRU队列 需要有一个HashMap完成key-\u003eNode的映射 需要有一个DoubleList来存放Node节点 有容量上限cap 使用私有的delete()/removeLast()/makeFirst()/addFirst()来辅助put()和get()方法，避免直接操作node 有put()/get()/size()方法 /** * @author TheR1sing3un * @date 2021/12/30 11:49 * @description LRU队列实现 */ public class LRUCache { //key-\u003enode的映射 private HashMap\u003cInteger,Node\u003e map; //双向链表作为缓存队列 private DoubleList cache; //最大容量 private int cap; //构造方法,并且完成map和list的初始化 public LRUCache(int cap){ this.cap = cap; map = new HashMap\u003cInteger,Node \u003e(); cache = new DoubleList(); } /** * 删除某个key对于的键值对 * @param key */ private void delete(int key){ //从map中获取该节点 Node node = map.get(key); //从链表删除该节点 cache.remove(node); //从map中删除该key map.remove(key); } /** * 删除缓存队列中最后一个节点,也就是最久未被使用的节点 */ private void removeLast(){ //从链表中删除该节点 Node node = cache.removeLast(); //根据该节点的key来删除map中对应的键值对 map.remove(node.key); //此处也就是为什么我们需要Node中存key的原因,因为需要根据key来删除map中的键值对 } /** * 将某个键提前到队首,也就是变成最近使用的节点 * @param key */ private void makeFirst(int key){ //从map中获取该节点 Node node = map.get(key); //删除该节点 cache.remove(node); //将该节点重新插入到队首 cache.addFirst(node); } /** * 添加一个键值对到队首,也就是到最近使用的位置 * @param key * @param val */ private void addFirst(int key,int val){ Node node = new Node(key,val); //添加到队首 cache.addFirst(node); //添加映射 map.put(key,node); } /** * 暴露出来的put()方法,向LRUCache中插入一个键值对,若key已存在则更新 * @param key * @param val */ public void put(int key,int val){ if (map.containsKey(key)){ //若key已存在,那么需要先删除旧数据 delete(key); //插入到队首 addFirst(key,val); return; } //当达到容量上限时 if(cache.size() == cap){ //删除最久未被使用的节点 removeLast(); } //添加到队首 addFirst(key,val); } /** * 暴露出来的get()方法,根据key获取到val,若不存在,则返回-1(假定val都为正整数) * @param key */ public int get(int key){ if (!map.containsKey(key)){ //key不存在 return -1; } //将该key移动到队首,也就是最近使用的第一个 makeFirst(key); //返回值　 return map.get(key).val; } /** * 暴露出来的size()方法,返回当前的大小 * @return 返回当前队列大小 */ public int size(){ return cache.size(); } /** * 打印缓存队列 */ public void print(){ cache.print(); } } ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:3:0","tags":["算法","Java","面试"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"测试 public class Test { public static void main(String[] args) { LRUCache lruCache = new LRUCache(5); Scanner sc = new Scanner(System.in); int key,val; while(true){ System.out.println(\"请输入插入的key和val(以空格隔开,输入-1则结束)\"); key = sc.nextInt(); if (key == -1) break; val = sc.nextInt(); lruCache.put(key,val); lruCache.print(); } while(true){ System.out.println(\"请输入需要获取的key(输入-1则结束)\"); key = sc.nextInt(); if (key == -1) break; System.out.println(\"key-\u003eval: \"+key+\"-\u003e\"+lruCache.get(key)); lruCache.print(); } } } 自行输入测试image-20211230132907832 \"\r自行输入测试\r 至此，我们就完成了一个简易的LRU算法，除此之外，我们还可以使用Java中自带的api来简化LRU实现 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:4:0","tags":["算法","Java","面试"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"LRU(使用LinkedHashMap) LinkedHashMap内部数据结构就是一条双向链表+HashMap，因此我们可以不用自己定义这些数据结构，具体实现交给LinkedHashMap，我们只需要处理put()/get()方法即可。 /** * @author TheR1sing3un * @date 2021/12/30 13:35 * @description 使用LinkedHashMap实现的LRU */ public class LRUCacheSimple { private int cap; private LinkedHashMap\u003cInteger,Integer\u003e cache = new LinkedHashMap(); public LRUCacheSimple(int cap){ this.cap = cap; } /** * 将某个键改成最近使用的 * @param key */ private void makeRecently(int key){ //先获取值 Integer val = cache.get(key); //删除该键 cache.remove(key); //重新插入 cache.put(key,val); } /** * 插入key,val * @param key * @param val */ public void put(int key,int val){ if (cache.containsKey(key)){ //如果已存在,那么覆盖 cache.put(key,val); //将key变成最近使用 makeRecently(key); return; } if (cap \u003c= cache.size()){ //当满了之后 //获取第一个key(也就是LinkedHashMap中最久未被访问的节点) Integer first = cache.keySet().iterator().next(); //删除该节点 cache.remove(first); } //将新的key,val插入 cache.put(key,val); } /** * 根据key获取value(假定value都是正整数) * @param key * @return value(-1表示不存在) */ public int get(int key){ if (!cache.containsKey(key)){ return -1; } //将该key变成最近使用的 makeRecently(key); return cache.get(key); } /** * 打印该缓存 */ public void print(){ Iterator\u003cInteger\u003e iterator = cache.keySet().iterator(); while(iterator.hasNext()){ int key = iterator.next(); System.out.print(key+\"-\u003e\"+ cache.get(key)+\" \"); } System.out.println(); } } ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:5:0","tags":["算法","Java","面试"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"总结 至此，我们就完成了两种方法手写LRU算法，不需要过多练习，只需要记住核心思想就是每次get时候我就提前，每次put也要提前，并且需要判断是否满载，若满则删除最后的(最久未被访问的节点)。 ","date":"2021-12-30","objectID":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/:6:0","tags":["算法","Java","面试"],"title":"LRU算法原理及实现","uri":"/lru%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["Spring"],"content":"SpringCould学习 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:0:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"前言 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:1:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"版本选择 SpringCloud:Hoxtom.SR1SpringBoot:2.2.2RELEASECloudAibaba:2.1.0RELEASeJava:1.8Maven:3.5及以上Mysql:5.7及以上 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:1:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"模块构建 新建项目 选择maven创建 选择骨架 修改字符编码 都改成utf-8 注解生效激活 设置java编译版本 File Type过滤(将项目下显示的一些杂七杂八的文件过滤掉) 将src删掉 将pom.xml中加入如下 统一管理jar包版本 \u003c!--统一管理Jar包版本--\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e12\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e12\u003c/maven.compiler.target\u003e \u003cjunit.version\u003e4.12\u003c/junit.version\u003e \u003clombok.version\u003e1.18.10\u003c/lombok.version\u003e \u003clog4j.version\u003e1.2.17\u003c/log4j.version\u003e \u003cmysql.version\u003e5.1.47\u003c/mysql.version\u003e \u003cdruid.version\u003e1.1.16\u003c/druid.version\u003e \u003cmybatis.spring.boot.version\u003e1.3.0\u003c/mybatis.spring.boot.version\u003e \u003c/properties\u003e 编写dependencyManagement 作用: 统一声明版本号 升级时只需该父工程的pom.xml中的版本号就可以处处升级 子模块不用写版本号 如果子模块要使用别的版本，只用自己声明version \u003c!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--\u003e \u003cdependencyManagement\u003e\u003c!--定义规范，但不导入--\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-project-info-reports-plugin\u003c/artifactId\u003e \u003cversion\u003e3.0.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--spring boot 2.2.2--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud Hoxton.SR1--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eHoxton.SR1\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud 阿里巴巴--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.1.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--mysql--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e${mysql.version}\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- druid--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e${druid.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--mybatis--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${mybatis.spring.boot.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e${junit.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--log4j--\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e${log4j.version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e 增加热启动插件 \u003c!--热启动插件--\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cfork\u003etrue\u003c/fork\u003e \u003caddResources\u003etrue\u003c/addResources\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e maven中跳过单元测试 父工程创建完成后执行 mvn:install将父工程发布到仓库方便子工程继承 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"支付模块构建 构建微服务模块统一步骤 建module 改pom 写yml 主启动 业务类 创建支付模块 创建module，继承自父亲模块(maven无骨架创建) 改pom文件 把需要使用的pom文件导入 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.10\u003c/version\u003e \u003c/dependency\u003e \u003c!--mysql-connector-java--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--jdbc--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 改yml 在模块下的resources下新建application.yaml server:port:8001#服务端口号spring:application:name:cloud-payment-service#服务名称datasource:type:com.alibaba.druid.pool.DruidDataSource#当前数据源操作类型driver-class-name:org.gjt.mm.mysql.Driver#mysql驱动包url:jdbc:mysql://${person.mysql.host}:${person.mysql.port}/springcloud?useUnicode-true\u0026charcterEncoding=utf-8\u0026useSSL=falseusername:rootpassword:lcy021030person:mysql:host:49.234.111.177port:3306 主启动类 创建主启动类 业务类 数据库建表 CREATE TABLE `payment` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID', `serial` varchar(200) DEFAULT '', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 创建实体类 @NoArgsConstructor @AllArgsConstructor @Data public class Payment implements Serializable { private Long id; private String serial; } @Data @AllArgsConstructor @NoArgsConstructor public class CommonResult\u003cT\u003e { public static final Integer SUCCESS = 20000; public static final Integer ERROR = 40000; private Integer code; private String message; private T data; public static CommonResult ok(){ return new CommonResult(SUCCESS,\"success\",null); } public static CommonResult error(){ return new CommonResult(ERROR,\"error\",null); } public CommonResult msg(String message){ this.message = message; return this; } public CommonResult code(int code){ this.code = code; return this; } public CommonResult\u003cT\u003e data(T data){ this.data = data; return this; } } 编写PaymentDao层 编写PaymentMapper 文件头 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"pro.risingsun.springcloud.dao.PaymentDao\"\u003e \u003c/mapper\u003e 写Service 写controller postman自测 创建消费者模块 创建模块 写实体类(Payment和CommonResult) 使用RestTemplate RestTemplate 创建config.ApplicationContexConfig 将RestTemplate注册成bean 完善消费者的OrderConsumer ​ 测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"工程重构 将部分相似的代码进行重构整合 创建新模块cloud-api-commons 写pom 将entites移入 放入本地库 maven:clean maven:install 改造原本的两个模块的公共内容 删掉entities 在各自的pom文件中引入 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Eureka 一种服务注册中心，使用Eureka的客户端连接到到Eureka Server并维持心跳连接。这样就可以通过Eureka Server来监控系统的各个微服务是否正常运行 EurekaServer 提供注册服务，各个微服务节点通过配置启动后，会从EurekaServer中心进行注册。这样RurekaSever中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到 EurekaClient 一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的、使用轮询负载算法的负载均衡器。在应用启动后，将会用EurekaServer发送心跳(默认30秒为一个周期)。如果EurekaServer在多个心跳周期内没有接收到某个节点的心跳，EurekaServer就会从服务注册表中把这个服务节点移除(默认90秒) ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"IDEA创建EurekaServer 创建模块 改pom \u003cdependencies\u003e \u003c!--自定义的api通用包--\u003e \u003cdependency\u003e \u003cgroupId\u003epro.risingsun.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!--eureka-server--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 写yaml server:port:7001eureka:instance:hostname:localhost#eureka服务端的实例名称client:register-with-eureka:false#不注册自己fetch-registry:false#false表示自己就是注册中心,不需要去检索自己的服务service-url:#设置与EurekaServer交互的地址查询服务和注册服务都需要依赖这个地址defaultzone:http://${eureka.instance.hostname}:${server.port}/eureka/ 写启动类 ​ 打上注解@EnbaleEurekaServer表示自己是EurekaServer 测试 输入localhost:7001 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"将payment注册进Eureka中 改pom 增加EurekaClient的依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 改配置 eureka:client:#表示自己注册进EurekaServerregister-with-eureka:true#是否从EurekaServer抓取已有的配置信息,默认为true(单节点无所谓,集群必须设置为true才可以配置ribbon使用负载均衡)fetch-registry:trueservice-url:defaultZone:http://localhost:7001/eureka#EurekeServer的地址 改主启动类 加上注解@EnableEurekaClient 启动测试 这里的应用名称是我们在yaml文件中配置的,如下图: ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"将order注册进Eureka中 步骤如上，基本一致 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"集群Eureka搭建 互相注册，相互守望 创建cloud-eureka-server7002 参考7001进行创建 修改映射文件 写yaml 互相注册，相互守望 修改7001的配置文件 修改7002的配置文件 主启动类 测试访问eureka7001:7001 测试访问eureka7002:7002 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:4","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"将服务注册进集群 改配置文件 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:5","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"PaymentProvider集群搭建 参考8001搭建8002和8003 修改consumer的服务调用URL 但是这样消费者还是找不到是哪个生产者，因为三个生产者的服务名称都是cloud-payment-service，因此需要开启负载均衡 开启负载均衡 使用@LoadBalances注解赋予RestTemplate负载均衡能力 集群信息完善 增加实例名称 在payment8001和8002的配置文件中增加 增加ip显示 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:6","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"服务发现 对于注册进eureke里面的微服务，可以通过服务发现来获得该服务的信息 修改cloud-provider-payment8001的Controller 主启动类增加注解 测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:7","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Eureka自我保护 某时刻某一个微服务不可用了，Eureka不会立刻清理，仍旧会对该微服务的消息进行保存 属于CAP中的AP分支 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:8","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"ZooKeeper ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"创建payment 服务器上启动Zookeeper 新建模块cloud-provider-payment8004 改pom文件 将Eureka的依赖改成zookeeper的 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zookeeper-discovery\u003c/artifactId\u003e \u003c/dependency\u003e 改配置文件(将Eureka的改成Zookeeper) 主启动类 写Controller 测试localhost:8004/payment/zk ​ ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"创建order …省略 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Consul … ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:5:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Ribbon Ribbon是一套实现负载均衡的工具 spring-cloud-starter-netflix-eureka-client已经集成了Ribbon 如何替换负载均衡策略 该配置类不能放在@CompomentScan可以扫到的位置 主启动类增加注解 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:6:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"OpenFeign 用在消费端 创建模块cloud-consumer-feign-order9000 改pom \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003epro.risingsun.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c!--eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--openfeign客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 改配置文件 server:port:9000spring:application:name:cloud-order-serviceeureka:client:register-with-eureka:truefetch-registry:trueservice-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版) 注册不注册都可以，消费端本来就不用注册 写主启动类 写服务调用接口 要点： 这里相当于是直接根据服务名和路径去服务端找相应的controller的方法，所以这里的服务名、路径、请求类型要一致才能在服务端找到方法 参数也要保证一致，而且需要打上相应的注解，没有SpringMVC帮忙封装了 负载均衡 自带负载均衡，使用Ribbon ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"OpenFeign超时控制 OpenFeign默认等待一秒钟 如果超过1秒种，Feign客户端直接报错 修改超时时间(OpenFeign自带Ribbon) ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"OpenFeign日志 日志级别: NONE：默认的，不显示任何日志 BASIC：仅记录请求方法、URL、相应状态码及执行时间 HEADERS：除了记录BASIC中定义的信息外，还有请求和相应的头信息 FULL：除了HEADERS中定义的信息外，还有请求和相应的正文及元数据 开启日志 创建日志配置类 配置文件中配置日志 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Hystix ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"重要概念 服务 降级 fallback 出现情况 程序运行异常 超时 服务熔断出发服务降级 线程池/常量池打满 服务熔断 当达到最大服务访问时，直接拒绝访问，然后调用服务降级 服务限流 限制服务访问 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 创建生产者 新建模块cloud-provider-hystrix-payment8005 pom文件 \u003c!--hystrix依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix\u003c/artifactId\u003e \u003c/dependency\u003e 写配置文件 写主启动类 写Service 写Controller 测试 创建消费者 … service，远程调用 controller 服务降级 服务提供方降级 激活服务降级功能 在主启动类上加上注解@EnbaleCircuitBeaker 使用注解@HystrixComman在业务方法上标记 服务消费方降级 改yml 改启动类 业务上处理 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"全局服务降级 现在的降级方式和业务代码耦合严重，而且重复冗余。那么需要进行全局的一个服务降级配置 @DefaultProerties(defaultFallback = “xxx”)设置默认的服务降级配置 如果某个方法有自己的配置，就用自己的，没有就用默认的 在Feign接口进行统一处理 写一个类实现PaymentFeignService接口，对方法进行重写 配置fallback ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"服务熔断 生产方Service代码如下 在错误了一定次数内失败率达到了设定值，那么进入熔断状态，然后在一定时间后(默认是5秒)会放出几个请求进去，如果还是错误降级了，那么就保持熔断状态，刷新休眠窗口期。如果请求正确了，那么熔断取消，正常运行。 参考链接 https://blog.csdn.net/loushuiyifan/article/details/82702522 参数说明 请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。 快照时间窗：断路器通过在统计一定时间内的请求和错误等数据决定是否开启熔断，而统计的时间范围就是快照时间窗，默认就是最近10秒 错误百分比阈值，当请求总数在快照时间窗内超过了阈值，而且错误请求的次数占的百分比超过了该错误百分比阈值，那么就会将断路器打开 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:4","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"监控页面 建模块 改pom 增加： \u003c!--hystrix仪表盘图形化页面--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix-dashboard\u003c/artifactId\u003e \u003c/dependency\u003e 改yml 写主启动类 启动，访问localhost:9001/hystrix 修改8005 监控8005 访问监控网址，测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:5","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"GateWay ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"入门配置 创建模块 改pom \u003c!--gateway网关--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e \u003c/dependency\u003e 写yml server:port:9527spring:application:name:cloud-gatewayeureka:instance:hostname:cloud-gateway-serviceclient:register-with-eureka:truefetch-registry:trueservice-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版) 写主启动类 写配置 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"动态路由 配置文件配置 server:port:9527spring:application:name:cloud-gatewaycloud:gateway:discovery:locator:enabled:true#开启从服务注册中心中动态创建路由的功能,利用微服务名进行路由routes:- id:payment_routh#配置路由的id,没有固定规则,但是要求唯一uri:lb://cloud-payment-service#匹配后提供的服务地址predicates:- Path=/payment/**#断言,根据路径进行路由##################- id:payment_routh2uri:lb://cloud-payment-service#匹配后提供服务的地址predicates:- Path=/service#断言,根据路径进行路由eureka:instance:hostname:cloud-gateway-serviceclient:#表示自己注册进EurekaServerregister-with-eureka:true#是否从EurekaServer抓取已有的配置信息,默认为true(单节点无所谓,集群必须设置为true才可以配置ribbon使用负载均衡)fetch-registry:trueservice-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版) 访问localhost:9527/payment/1测试 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"常用Predicate 也就是常用的断言配置 After Route Predicate 请求时间在该时间之后可以匹配 在配置文件中配置 可以通过如下Api进行获得该格式的日期: 在该日期之前无法访问 该日期之后可以访问 Before Route Predicate 请求的时间在这个时间之前可以匹配 Between Route Predicate 请求时间在两个时间内，可以匹配 Cookie Route Predicate 匹配Cookie断言 需要两个参数，第一个是Cookie name，第二个是政策表达式 Gateway会去检验对应的Cookie的value是否符合正则表达式 配置Predicate Header Route Predicate 请求头中进行匹配 两个参数，一个是请求头名，一个是值 测试不匹配 测试匹配 Method Route Predicate Path Route Predicate Query Route Predicate ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Filter 自定义全局日志过滤器 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:4","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Config ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"服务端(连接github) 微服务统一配置 建模块cloud-config-center-3344 写pom 增加 \u003c!--配置中心--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-config-server\u003c/artifactId\u003e \u003c/dependency\u003e 写配置文件 主启动类 测试localhost:3344/master/config-dev.yml 如果连接失败，使用ssh方式连接，使用旧方法创建私匙，在github中添加，然后配置文件中改成ssh的地址 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"客户端(连接服务端) 创建模块cloud-config-client-3355 改pom \u003c!--配置中心客户端--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-config\u003c/artifactId\u003e \u003c/dependency\u003e 写bootstrap.yml application.yml是用户级的资源配置 bootstrap.yml是系统级，优先级更高 写主启动类 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"客户端动态更新 服务端可以实时更新，但是客户端不能实时更新 引入监控依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e 配置文件暴露监控端点 在controller添加注解@RefreshScope ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:3","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Bus 什么是总线？ 在微服务架构的系统总，通常用使用轻量级的消息代理来构建一个公用的消息主题，并让系统中所有微服务的实例都连接上来，由于该主题中产生的消息会被所有实例监听和消费，所以称它为消费总线。在总线上的各个实例，都可以方便的广播一些需要其他连接到该主题上的实例都知道的消息 基本原理 ConfigClient实例都监听MQ中同一个topic(默认是SpringCloudBus)。当一个服务刷新数据的时候，它会把这个消息放入到Topic中，这样其他监听同一Topic的服务就能得到通知，然后去更新自身的配置 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:11:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 再创建一个cloud-config-client-3366，步骤略 设计 利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端配置 利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置 方法二更适合 服务端添加Rabbitmq \u003c!--整合rabbitmq的bus消息总线--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amqp\u003c/artifactId\u003e \u003c/dependency\u003e 增加rabbitmq的配置 增加暴露刷新配置的端点 3344和3355添加消息总线的支持 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amqp\u003c/artifactId\u003e \u003c/dependency\u003e rabbitmq:host:49.234.111.177port:5672username:lcypassword:lcy021030 发送请求POST: localhost:3344/actuator/bus-refresh完成自动更新 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:11:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Stream 驱动，屏蔽底层消息中间件的差异 应用程序通过inputs或者outputs来与SpringCloudStream中的binder对象交互 通过配置来绑定(binding)，而SpringCloudStream的binder对象负责与消息中间件交互 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 生产者 创建模块cloud-stream-rabbitmq-provider8801 写pom \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rabbit\u003c/artifactId\u003e \u003c/dependency\u003e 写yml server:port:8801spring:application:name:cloud-stream-providercloud:stream:bindings:# 服务的整合处理output:# 这个名字是一个通道的名称destination:studyExchange# 表示要使用的Exchange名称定义content-type:application/json# 设置消息类型，本次为json，文本则设置“text/plain”binder:rabbit1# 设置要绑定的消息服务的具体设置#可以配置多个底层MQ的配置binders:# 在此处配置要绑定的rabbitmq的服务信息；rabbit1:# 表示定义的名称，用于于binding整合type:rabbit# 消息组件类型environment:# 设置rabbitmq的相关的环境配置spring:rabbitmq:host:49.234.111.177port:5672username:lcypassword:lcy021030rabbitmq:host:49.234.111.177port:5672username:lcypassword:lcy021030eureka:client:service-url:defaultZone:http://eureka7001:7001/eureka,http://eureka7002:7002/eureka#EurekeServer的地址(集群版)instance:instance-id:send-8801.com#在信息列表显示的主机名称lease-renewal-interval-in-seconds:2#设置心跳的时间(默认是30秒)lease-expiration-duration-in-seconds:5prefer-ip-address:true 写主启动类 写业务接口 消费者 新建模块cloud-stream-rabbitmq-consumer8802 写pom 写yml 写业务 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"重复消费 此时两个消费者是不同组的，都监听一个交换机，所以都会收到消息，因此我们需要将两个消费者放到同一个组中 自定义分组 如果我们不自定义分组，那么默认使用的是不同的分组，因此可以自定义选择分组 在8802和8803中加入分组，那么收到的就是将两个消费者监听在同一个组中，消息则只能被消费一次 此时两个消费者就轮询接受消息。 原理 其实就是rabbitmq中的fandout和direct，默认情况两个消费者是不同的队列，然后绑定到同一个交换机，那么我们生产者生产一个消息到交换机，就会被两个队列都拿到。 当我们配置了组名时，其实就是变成了同一个队列，那么生产的消息发送到交换机时，交换机只发了一条消息给队列，那么监听同一个队列的消费者，只有一个能消费到消息，默认是轮询消费 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"Sleuth SpringCloudSleuth提供了分布式追踪的解决方案 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:0","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"搭建zipkin 下载jar包后直接启动 访问localhost:9411查看面板 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:1","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["Spring"],"content":"实践 cloud-provider8001添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e 改配置 在consumer做一样的依赖和配置 ","date":"2021-12-09","objectID":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:2","tags":["Java","SpringCloud","微服务"],"title":"SpringCloud基础学习","uri":"/springcloud%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":" 西安电子科技大学2020级本科在读 一个想写Golang的Javaer 首要目标是顺利毕业 远大目标是在35岁之前光荣退休 ","date":"2021-12-09","objectID":"/about/:0:0","tags":null,"title":"关于 TheR1sing3un","uri":"/about/"},{"categories":null,"content":"以下是我的朋友们 对底层比较执着的大佬兼我的舍友 🐧刘陶峰的个人博客 难得一遇的超级前端大哥 🍅大faga的个人博客 前端+ACM双修的神 🔮Littlechai的个人博客 算法竞赛大神和后端开发同届大佬 🏆Attack204的个人博客 ","date":"2021-12-09","objectID":"/friendship/:0:0","tags":null,"title":"我的朋友","uri":"/friendship/"},{"categories":["开发工具学习"],"content":"Linux下开发工具之Tmux","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"Tmux学习 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:0:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"一.什么是Tmux ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:1:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"1.1传统命令行 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称\"窗口\"），在里面输入命令。用户与计算机的这种临时的交互，称为一次\"会话\"（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 为了解决这个问题，会话与窗口可以\"解绑\"：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话\"绑定\"其他窗口。 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:1:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"1.2Tmux作用 将会话与窗口解绑的工具 功能 允许在单个窗口中，同时访问多个会话。 可以让新窗口接入已经存在的会话 允许每个会话有多个连接窗口，可以多人实时共享会话 支持窗口任意的垂直和水平拆分 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:1:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"二.基本用法 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"2.1安装 centos系统下的安装 sudo yum install tmux ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"2.2启动和退出 启动 tmux 启动Tmux窗口,底部有一个状态栏。状态栏左侧是窗口信息(编号和名称)，右侧是系统信息 退出 exit或者Ctrl + D ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"2.3前缀键 Tmux的快捷键需要前缀键进行唤醒，默认前缀键是 Ctrl + B。先按下前缀键，快捷键才会生效 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:2:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"三.会话管理 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.1新建会话 默认启动的Tmux窗口编号从0开始，我们可以自己给会话起名字 tmux new -s \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.2分离会话 分离会话 在Tmux窗口下，按住Ctrl + B D或者输入tmux detach，就会将当前会话和窗口分离，上面命令执行后，就会退出当前的Tmux窗口，但是后台仍在运行里面的会话和进程 查看所有会话 tmux ls ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.3接入会话 用于重新接入某个已经存在的会话 tmux attach -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.4杀死会话 tmux kill-session -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:4","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.5切换会话 tmux switch -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:5","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.6重命名会话 tmux rename-session -t \u003csession-name\u003e \u003cnew-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:6","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"3.7会话快捷键 Ctrl + B D：分离当前会话 Ctrl + B S：列出所有会话 Ctrl + B $：重命名当前会话 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:3:7","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"四.最简操作流程 新建会话tmux new -s \u003csession-name\u003e 在Tmux窗口运行所需的程序 按下快捷键Ctrl +B D将会话分离 下次使用时，重新连接到会话tmux attach-session -t \u003csession-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:4:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"五.网格操作 Tmux可以将窗口分成多个窗格，每个窗格运行不同的命令 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.1划分窗格 tmux split-window #划分上下两个窗格 tmux split-window -h #划分左右两个窗格 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.2移动光标 使用tmux select-pane命令用来移动光标位置 tmux select-pane -U #光标切换到上方窗格 tmux select-pane -D #光标切换到下方窗格 tmux select-pane -L #光标切换到左边窗格 tmux select-pane -R #光标切换到右边窗格 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.3交换窗格位置 tmux swap-pane 命令来交换窗格位置 tmux swap-pane -U #当前窗格上移 tmux swap-pane -D #当前窗格下移 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"5.4窗格快捷键 Ctrl+b %：划分左右两个窗格。 Ctrl+b \"：划分上下两个窗格。 Ctrl+b \u003carrow key\u003e：光标切换到其他窗格。\u003carrow key\u003e是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。 Ctrl+b ;：光标切换到上一个窗格。 Ctrl+b o：光标切换到下一个窗格。 Ctrl+b {：当前窗格与上一个窗格交换位置。 Ctrl+b }：当前窗格与下一个窗格交换位置。 Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 Ctrl+b x：关闭当前窗格。 Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+\u003carrow key\u003e：按箭头方向调整窗格大小。 Ctrl+b q：显示窗格编号 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:5:4","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"六.窗口管理 Tmux允许新建多个窗口 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.1新建窗口 tmux new-window命令用来创建新窗口 tmux new-window #新建一个窗口 tmux new-wndow -n \u003cwindow-name\u003e #新建一个指定名称的窗口 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:1","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.2切换窗口 tmux select-window命令用来切换窗口 tmux select-window -t \u003cwindow-number\u003e #切换到指定编号的窗口 tmux select-window -t \u003cwidnow-name\u003e #切换到指定编号的窗口 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:2","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.3重命名窗口 tmux rename-window命令用于为当前窗口起名(或重命名) tmux rename-window \u003cnew-name\u003e ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:3","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"6.4窗口快捷键 Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。 Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。 Ctrl+b n：切换到下一个窗口。 Ctrl+b \u003cnumber\u003e：切换到指定编号的窗口，其中的\u003cnumber\u003e是状态栏上的窗口编号。 Ctrl+b w：从列表中选择窗口。 Ctrl+b ,：窗口重命名。 ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:6:4","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"七.其他命令 # 列出所有快捷键，及其对应的 Tmux 命令 tmux list-keys # 列出所有 Tmux 命令及其参数 tmux list-commands # 列出当前所有 Tmux 会话的信息 tmux info # 重新加载当前的 Tmux 配置 tmux source-file ~/.tmux.conf ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:7:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"},{"categories":["开发工具学习"],"content":"八.参考连接 https://www.ruanyifeng.com/blog/2019/10/tmux.html ","date":"2021-12-09","objectID":"/tmux%E5%AD%A6%E4%B9%A0/:8:0","tags":["linux","开发工具"],"title":"Tmux学习","uri":"/tmux%E5%AD%A6%E4%B9%A0/"}]